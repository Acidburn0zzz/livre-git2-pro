[[_git_notes]]
=== Notes

Une des choses appréciables de Git est qu'il a une forte intégrité cryptographique.
Si vous changez n'importe quel bit dans la donnée de validation ou n'importe quel fichier qu'il contient, toutes les sommes de contrôle changent, y compris le SHA du _commit_ et le SHA de chaque _commit_ depuis celui-là.
Cependant, cela signifie que pour corriger le _commit_ d'une quelconque manière, par exemple pour ajouter des commentaires sur quelque chose ou même signer un _commit_, vous devez changer le SHA du _commit_ lui-même.

Est-ce que ça ne serait pas bien si vous pouviez ajouter des données à un _commit_ sans changer son SHA ?
A cet effet, Git a un mécanisme appelé `git notes` pour attacher des données à un _commit_ sans modifier le message de validation lui-même.

Pour ajouter une note à un _commit_ spécifique, vous n'avez besoin que de lancer `git notes add [_commit_]`, comme ceci :

[source,console]
----
$ git notes add HEAD
----

Ceci ouvrira votre éditeur pour écrire votre note.
Vous pouvez aussi utiliser l'option `-m-` pour fournir la note dans la ligne de commande :

[source,console]
----
$ git notes add -m 'I approve - Scott' master~1
----

Cela ajoutera une note au premier parent du dernier _commit_ de la branche `master`.
Maintenant, comment voir ces notes ?
Le moyen le plus facile est avec la commande `git log`.

[source,console]
----
$ git log master
commit 0385bcc3bc66d1b1ec07346c237061574335c3b8
Author: Ryan Tomayko <rtomayko@gmail.com>
Date:   Tue Jun 22 20:09:32 2010 -0700

  yield to run block right before accepting connections

commit 06ca03a20bb01203e2d6b8996e365f46cb6d59bd
Author: Ryan Tomayko <rtomayko@gmail.com>
Date:   Wed May 12 06:47:15 2010 -0700

  no need to delete these header names now

Notes:
  I approve - Scott
----

Vous pouvez voir les notes ajoutées automatiquement dans la sortie de log.
Vous ne pouvez cependant avoir qu'une seule note par _commit_ dans un espace de nom (j'expliquerai les espaces de nom dans la prochaine section), donc si vous voulez ajouter une note à ce _commit_, vous devez à la place éditer celle existante.
Quoi qu'il en soit, vous pouvez faire cela en lançant :

[source,console]
----
$ git notes edit master~1
----

Ce qui ouvrira un éditeur de texte avec la note existante que vous pourrez alors éditer :

[source,console]
----
I approve - Scott

#
# Write/edit the notes for the following object:
#
# commit 06ca03a20bb01203e2d6b8996e365f46cb6d59bd
# Author: Ryan Tomayko <rtomayko@gmail.com>
# Date:   Wed May 12 06:47:15 2010 -0700
#
#     no need to delete these header names now
#
#  kidgloves.rb |    2 --
#  1 files changed, 0 insertions(+), 2 deletions(-)
~
~
~
".git/NOTES_EDITMSG" 13L, 338C
----

Si vous voulez seulement ajouter quelque chose à la fin de la note existante, vous pouvez lancer `git notes append SHA`.

Enfin, vous pouvez lui donner un fichier avec le contenu que vous voulez ajouter en tant que note avec l'option `-F`.
Ceci pourrait être utile pour ajouter de plus grandes quantités de contenu aux _commits_, peut-être des courriels ou une sortie construite.

=== Les espaces de nom de notes

Puisque vous ne pouvez avoir qu'une seule note par _commit_, Git vous autorise à avoir de multiples espaces de nom pour vos notes.
L'espace de nom par défaut est appelé « _commits_ », mais vous pouvez le changer.
Disons que nous utilisons l'espace de nom de notes « _commits_ » pour stocker des commentaires généraux mais que nous voulons aussi stocker des informations bugzilla pour nos _commits_.
Nous pouvons aussi avec un espace de nom « bugzilla ».
Voici comment nous ajouterions un numéro de bug à un _commit_ sous l'espace de nom bugzilla :

[source,console]
----
$ git notes --ref=bugzilla add -m 'bug #15' 0385bcc3
----

Cependant, vous devez maintenant dire à Git de regarder spécifiquement dans cet espace de nom avec l'option `--notes` :

[source,console]
----
$ git log --notes=bugzilla
commit 0385bcc3bc66d1b1ec07346c237061574335c3b8
Author: Ryan Tomayko <rtomayko@gmail.com>
Date:   Tue Jun 22 20:09:32 2010 -0700

  yield to run block right before accepting connections

Notes (bugzilla):
  bug #15

commit 06ca03a20bb01203e2d6b8996e365f46cb6d59bd
Author: Ryan Tomayko <rtomayko@gmail.com>
Date:   Wed May 12 06:47:15 2010 -0700

  no need to delete these header names now

----

Notez qu'il ne vous montrera que les notes de l'espace de nom que vous indiquez.
Vous pouvez passer l'option plusieurs fois pour voir les notes de multiples espaces de nom.
Vous pouvez aussi lui faire montrer les notes de tous les espaces de nom en lançant `git log --notes=*`.
Voici à quoi ressemblerait votre sortie de log si vous avez un certain nombre d'espaces de nom de notes :

[source,console]
----
$ git log -1 --notes=*
commit 0385bcc3bc66d1b1ec07346c237061574335c3b8
Author: Ryan Tomayko <rtomayko@gmail.com>
Date:   Tue Jun 22 20:09:32 2010 -0700

    yield to run block right before accepting connections

Notes:
    I approve of this, too - Scott

Notes (bugzilla):
    bug #15

Notes (build):
    build successful (8/13/10)
----

Vous pouvez aussi basculer l'espace de nom courant que vous utilisez afin que, par défaut, pour l'écriture et l'affichage des notes, ce ne soit pas "_commits_" mais, disons, "bugzilla" à la place.
Ça se fait avec la variable de configuration `core.notesRef`.
Par exemple, vous pourriez lancer ceci pour changer celui par défaut :

[source,console]
----
$ git config core.notesRef refs/notes/bugzilla
----

[[_sharing_notes]]
=== Partager les notes

Les notes (comme vous avez pu le constater dans la section précédente) sont stockées comme des références, exactement comme les branches et les étiquettes.
Ceci signifie que vous pouvez les pousser vers un serveur.
Toutefois, Git a un mécanisme un peu magique pour développer un nom de branche comme `master` vers son nom complet, qui est `refs/heads/master/`.
Malheureusement, Git ne possède pas un tel mécanisme magique pour les notes.
Donc, pour pousser vos notes vers un serveur, vous ne pouvez pas lancer simplement quelque chose comme `git push origin bugzilla`.
Git fera ceci :

[source,console]
----
$ git push origin bugzilla
error: src refspec bugzilla does not match any.
error: failed to push some refs to 'https://github.com/schacon/kidgloves'
----

Cependant, vous pouvez pousser n'importe quelle chose sous `refs/` vers un serveur, vous devez seulement être un peu plus explicite à ce propos.
Lancer la commande suivante fonctionnera correctement :

[source,console]
----
$ git push origin refs/notes/bugzilla
Counting objects: 3, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 263 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/schacon/kidgloves
 * [new branch]      refs/notes/bugzilla -> refs/notes/bugzilla
----

En fait, vous pouvez vouloir que faire seulement `git push origin refs/notes/*` poussera toutes vos notes.
C'est ce que fait normalement Git avec quelque chose comme les étiquettes.
Quand vous lancez `git push origin --tags`, il développe simplement vers `git push origin refs/tags/*`.

[[_getting_notes]]
==== Obtenir les notes

Malheureusement, obtenir les notes est encore plus difficile.
Les notes ne viennent pas avec un clone et il n'y a rien comme `git fetch --notes`.
Afin de tirer les notes, vous devez spécifier les deux côtés de la refspec.

[source,console]
----
$ git fetch origin refs/notes/*:refs/notes/*
remote: Counting objects: 12, done.
remote: Compressing objects: 100% (8/8), done.
remote: Total 12 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (12/12), done.
From github.com:schacon/kidgloves
 * [new branch]      refs/notes/bugzilla -> refs/notes/bugzilla
----

C'est en gros la seule façon de les obtenir dans votre dépôt depuis le serveur.
Ce qui est probablement plus commun est de définir votre fichier de configuration Git pour les tirer automatiquement quand vous tirez.
Si vous regardez votre fichier `.git/config`, vous devriez avoir une section qui ressemble à ceci :

[source,console]
----
[remote "origin"]
  fetch = +refs/heads/*:refs/remotes/origin/*
  url = https://github.com/schacon/kidgloves
----

La ligne "fetch" est la refspec de ce que Git essaiera de faire si vous lancez seulement `git fetch origin`.
Elle contient la formule magique de ce que Git ira chercher et où il stockera les références locales.
Par exemple, dans ce cas, il prendra chaque branche sur le serveur et vous donnera une branche locale sous "remotes/origin/" afin que vous puissez référencer la branche `master` sur le serveur comme `remotes/origin/master` ou seulement `origin/master` (il regardera sous `remotes/` quand il essaiera de comprendre ce que vous faites).
Si vous changez cette ligne par `fetch = +refs/heads/*:refs/remotes/manamana/*`, alors même si votre serveur distant est appelé `origin`, la branche `master` de votre serveur `origin` sera sous `manamana/master`.

Vous pouvez utiliser cela pour faciliter l'obtention des notes.
Si vous ajoutez de multiples lignes `fetch`, il les fera toutes.
Donc, en plus de la ligne `fetch` courante, vous pouvez ajouter une ligne qui ressemble à ceci :

[source,console]
----
fetch = +refs/notes/*:refs/notes/*
----

Ce qui dit aussi « Va chercher toutes les références de notes sur le serveur et stocke-les comme si c'était des notes locales. ».

=== Collaboration sur les notes

[source,console]
----
[remote "origin"]
	url = git@github.com:schacon/test.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[remote "notes"]
	url = git@github.com:schacon/test.git
	fetch = +refs/notes/*:refs/remote-notes/origin/*
	push  = refs/notes/*:refs/notes/*
----

[source,console]
----
$ git push notes
Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 267 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@github.com:schacon/test.git
 * [new branch]      refs/notes/commits -> refs/notes/commits
----

[source,console]
----
$ git fetch notes
From github.com:schacon/test
 * [new ref]         refs/notes/commits -> refs/remote-notes/origin/commits
----

[source,console]
----
$ git notes append -m 'my note' 1871649b61b87864c64bd0d7c9c2c88523968f6c
----

[source,console]
----
$ git push notes
To git@github.com:schacon/test.git
 ! [rejected]        refs/notes/commits -> refs/notes/commits (non-fast-forward)
error: failed to push some refs to 'git@github.com:schacon/test.git'
hint: Updates were rejected because a pushed branch tip is behind its remote
hint: counterpart. Check out this branch and integrate the remote changes
hint: (e.g. 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
----

[source,console]
----
$ git notes merge refs/remote-notes/origin/commits
Fast-forward
----

A FAIRE: Je n'arrive pas du tout à faire marcher `git notes merge`. Peut-être devrais-je retirer cette section.

Jusqu'à présent, j'ai entendu que des gens les utilisent pour que leur système de ticket attache des méta-données automatiquement ou pour faire attacher des courriels de liste de diffusion associés aux _commits_ qu'ils concernent à <a href="http://article.gmane.org/gmane.comp.version-control.git/109074">un système</a>.
D'autres gens les utilisent entièrement localement sans les pousser où que ce soit pour stocker des mémos pour eux-mêmes et ainsi de suite.
Probablement un bon début, mais les ambitieux parmi vous peuvent trouver autre chose d'intéressant à faire.
Tenez-moi au courant !
