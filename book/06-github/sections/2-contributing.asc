=== Contribuer à un projet

Après avoir créé un compte, examinons comment contribuer à un projet existant.

==== Dupliquer des projets

(((Dupliquer)))
Si vous souhaitez contribuer à un projet existant sur lequel vous n'avez pas le droit de pousser, vous pouvez dupliquer (_fork_) ce projet.
Cela signifie que GitHub va faire une copie du projet qui vous appartiendra.
Elle se situe dans votre espace de nom et vous pouvez pousser dessus.

[NOTE]
====
Historiquement, le terme « _fork_ » transmet une idée négative, qui s'apparente à l'idée que quelqu'un mène un projet open source vers une direction différente, créant un projet concurrent de l'original et divisant les forces de contributions.
Au sein de GitHub, un « _fork_ » constitue une simple copie au sein de votre espace de nom, ce qui vous permet d'y apporter des modifications et de les publier, plus comme un moyen de contribuer de manière plus ouverte.
====

De cette manière, les projets n'ont pas à se soucier de devoir ajouter des utilisateurs comme collaborateurs pour leur accorder un accès en poussée.
Les personnes peuvent dupliquer un projet, pousser sur leur copie et fournir leur contribution au dépôt originel en créant une requête de tirage (_Pull Request_), concept qui sera traité ci-après.
Ceci ouvrir un fil de discussion avec possibilité de revue de code, pour que le propriétaire et le contributeur puissent discuter et modifier le code proposé jusqu'à ce que le propriétaire soit satisfait du résultat et le fusionne dans son dépôt.

Pour dupliquer un projet, visitez la page du projet et cliquez le bouton « _Fork_ » en haut à droite de la page.

.Le bouton  « _Fork_ ».
image::images/forkbutton.png[Le bouton  « _Fork_ ».]

Quelques secondes après, vous serez redirigé vers la page de votre nouveau projet, contenant votre copie modifiable du code.

[[_github_flow]]
==== Déroulement GitHub

(((GitHub, déroulement)))
Github est construit autour d'une certaine organisation de la collaboration, centrée autour des requêtes de tirage.

Ce flux de travail fonctionne aussi bien que vous soyez une petite équipe collaborant sur un dépôt unique partagé ou une société éclatée à travers le monde ou un réseau d'étrangers contribuant sur un projet au moyen de dizaines de projets dupliqués.
Il est centré sur le flux de travail par branches thématiques (voir <<_topic_branch>> traité dans <<_git_branching>>).

Le fonctionnement général est le suivant :

1. création d'un branche thématique à partir de `master`,
2. validation de quelques améliorations,
3. poussée de la branche thématique sur votre projet GitHub,
4. ouverture d'une demande de tirage sur GitHub,
5. une discussion s'engage avec la possibilité d'ajouter de _commits_,
6. le propriétaire du projet fusionne ou ferme la requête de tirage.

C'est en gros le flux de gestion par gestionnaire d'intégration traité dans <<_integration_manager>>, mais au lieu d'utiliser des mails pour communiquer et faire une revue des modifications, les équipes utilisent les outils Web de GitHub.

Détaillons un exemple illustrant de proposition d'une modification à un projet open source hébergé sur GitHub.

===== Création d'une requête de tirage

Tony recherche un programme à faire tourner sur son micro-contrôleur Arduino et a trouvé un programme génial sur GitHub à https://github.com/schacon/blink[].

.Le projet auquel nous souhaitons contribuer.
image::images/blink-01-start.png[Le projet auquel nous souhaitons contribuer.]

Le seul problème est que le clignotement est trop rapide, nous pensons qu'il serait mieux d'attendre 3 secondes au lieu d'une entre chaque changement d'état.
Améliorons donc le programme et soumettons cette amélioration au projet initial.

Premièrement, nous cliquons sur le bouton « Fork » comme mentionné ci-dessus pour obtenir une copie du projet.
Notre nom d'utilisateur ici est « tonychacon » donc notre copie de ce projet est à `https://github.com/tonychacon/blink` et c'est ici que nous pouvons l'éditer.
Nous pouvons le cloner localement, créer une branche thématique, modifier le code et pousser finalement cette modification sur GitHub.

[source,shell]
----
$ git clone https://github.com/tonychacon/blink <1>
Clonage dans 'blink'...

$ cd blink
$ git checkout -b slow-blink <2>
Basculement sur la nouvelle branche 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino <3>

$ git diff --word-diff <4>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <5>
[master 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <6>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -> slow-blink
----

<1> Clone notre copie du projet localement
<2> Crée un branche thématique avec un nom descriptif
<3> Modifie le code
<4> Vérifie si la modification est bonne
<5> Valide les modifications dans la branche thématique
<6> Pousse notre branche thématique sur notre dépôt dupliqué GitHub

Maintenant, si nous allons sur notre projet dupliqué sur GitHub, nous pouvons voir que GitHub a remarqué que nous avons poussé une nouvelle branche thématique et nous présente un gros bouton vert pour revoir nos modifications et ouvrir une requête de tirage sur le projet original.

Vous pouvez aussi vous rendre à la page « Branches » à `https://github.com/<utilisateur>/<projet>/branches` pour trouver votre branche et ouvrir une requête de tirage.

.Le bouton Pull
image::images/blink-02-pr.png[Le bouton Pull Request]

(((GitHub, requêtes de tirage)))
Si nous cliquons sur le bouton vert, un écran nous permet de créer un titre et une description de la modification que nous souhaitons faire intégrer pour que le propriétaire du projet trouve un bonne raison de la revoir.
C'est généralement une bonne idée de passer un peu de temps à écrire une description aussi argumentée que possible pour que le propriétaire sache pourquoi la modification est proposée et en quoi elle apporterait une amélioration au projet.

Nous voyons aussi une liste de commits dans notre branche thématique qui sont « en avance » (_ahead_) de la branche `master` (dans ce cas, juste un) et un diff unifié des toutes les modifications qui seraient intégrées en cas de fusion.

.Page de création d'un requête de tirage
image::images/blink-03-pull-request-open.png[Page de création d'un requête de tirage]

Quand vous cliquez le bouton « Create pull request » sur cet écran, le propriétaire du projet que vous avez dupliqué reçoit une notification que quelqu'un suggère une modification et qui renvoie à une page contenant toutes les informations correspondantes.

[NOTE]
====
Bien que les requêtes de tirage soient souvent utilisées pour les projets publics similaires quand un contributeur propose une modification complète, elles sont aussi utilisées souvent dans les projets internes _au début_ du cycle de développement.
Comme on peut continuer à pousser sur la branche thématique même *après* l'ouverture de la requête de tirage, on ouvre une requête de tirage très tôt et cela permet de travail en équipe dans un contexte, plutôt que de l'ouvrir à la toute fin de processus.
====

===== Itération sur une requête de tirage

À présent, le propriétaire du projet peut regarder les modifications suggérées et les fusionner, ou les rejeter ou encore les commenter.
Supposons qu'il apprécie l'idée mais préférerait un temps d'extinction de la lumière légèrement plus long que le temps d'allumage.

Cette conversation peut avoir lieu par mail dans les flux de travail présentés dans <<_distributed_git>> et en ligne sur GitHub.
Le propriétaire du projet peut faire une revue des diffs unifiés et laisser un commentaire en cliquant une des lignes.

.Commentaire sur une ligne spécifique de la requête de tirage
image::images/blink-04-pr-comment.png[ligne commentée sur un requête de tirage]

Un fois que le mainteneur a commenté, la personne qui a ouvert le requête de tirage (ou en fait toute personne surveillant le dépôt) recevra une notification.
Nous verrons comment personnaliser ce comportement plus tard, mais si la notification par mails est activée, Tony recevra un mail comme celui-ci :

[[_email_notification]]
.Des commentaires comme notifications par mail
image::images/blink-04-email.png[Notification par mail]

N'importe qui peut aussi laisser un commentaire général sur la requête de tirage.
Dans <<_pr_discussion>>, nous pouvons voir une exemple où le propriétaire du projet commente une ligne de code puis laisse un commentaire général dans la section de discussion.
Vous pouvez voir que les commentaires de code sont aussi publiés dans la conversation.

[[_pr_discussion]]
.Page de discussion de Pull Request
image::images/blink-05-general-comment.png[Page de discussion de PR]

Maintenant, le contributeur peut voir ce qu'il doit faire pour avoir ses modifications intégrées.
Heureusement, c'est une chose facile à faire.
Tandis que par mail, il faut retravailler les série de commit et la soumettre à nouveau à la liste de diffusion, avec GitHub il suffit d'ajouter les correctifs sur la branche thématique et de la repousser.

Le propriétaire du projet sera notifié à nouveau des modifications du contributeur et pourra voir que les problèmes ont été réglés quand il visitera la page de la requête de tirage.
En fait, comme un ligne de code initialement commentée a été modifié entre temps, GitHub le remarque et écrase le diff obsolète.

[[_pr_final]]
.Pull Request finale
image::images/blink-06-final.png[PR finale]

Un point intéressant à noter est que si vous cliquez sur l'onglet « Files Changed », vous obtenez le diff unifié -- c'est-à-dire la différence totalement agrégée qui serait introduite dans votre branche principale si cette branche thématique était fusionnée.
En équivalent `git diff`, cela montre automatiquement la même chose que `git diff master...<branche>` pour la branche pour laquelle vous avez ouvert la Pull Request.
Référez-vous à <<_what_is_introduced>> pour plus d'information sur ce type de diff.

L'autre point à noter est que GitHub vérifie si la requête de tirage peut être fusionnée proprement et fournit un bouton pour réaliser la fusion sur le serveur.
Ce bouton n'apparaît que si vous avez accès en écriture au dépôt et si une fusion peut s'effectuer simplement.
Si vous cliquez dessus, GitHub réalise une fusion sans avance rapide, ce qui signifie que même si la fusion pouvait se faire en avance rapide, il va tout de même créer un commit de fusion.

Si vous préférez, vous pouvez simplement tirer la branche et la fusionner localement.
Si vous fusionnez cette branche dans `master` et poussez le tout sur GitHub, la Pull Request sera fermée automatiquement.

C'est le flux de travail de base que la plupart des projets GitHub utilisent.
Les branches thématiques sont créées, les requêtes de tirages sont ouvertes dessus, une discussion s'engage, du travail additionnel peut être ajouté sur la branche et à la fin, la requête est soit fermée, soit fusionnée.

[NOTE]
.Pas seulement avec des dépôts répliqués
====
Il est important de noter que vous pouvez aussi ouvrir une requête de tirage entre deux branches du même dépôt.
Si vous travaillez sur une fonctionnalité avec quelqu'un et que vous avez tous deux accès en écriture au projet, vous pouvez pousser une branche thématique sur le dépôt et ouvrir un requête de tirage dessus vers la branche `master` de ce même projet pour démarrer une revue de code et une discussion.
Aucune duplication n'est nécessaire.
====

==== _Pull requests_ avancées

Après avoir traité les bases de la contribution à un projet sur GitHub, voyons quelques trucs et astuces d'efficacité concernant les requêtes de tirage.

===== _Pull requests_ comme patches

Il est important de comprendre que pour de nombreux projets, les requêtes de tirage sont vues comme des piles de patchs parfaits qui doivent s'appliquer dans l'ordre, ce que la plupart de projets dont les interactions reposent sur une liste de diffusion voient comme une série de patchs envoyés par mail.
La plupart des projets GitHub pensent les branches de requête de tirage comme des conversations itératives autour d'une modification proposée, aboutissant à un diff unifié qui est appliqué par fusion.

C'est une distinction importante, car généralement la modification est soumise à revue avant que le code ne soit considéré comme parfait, ce qui est bien plus rare avec les contributions par série de patchs basées envoyées sur une liste de diffusion.
Cela permet à une conversation avec les mainteneurs d'apparaître très tôt de sorte que l'on atteint une solution correcte par un travail communautaire.
Quand du code est proposé par requête de tirage et que les mainteneurs ou la communauté suggère des modifications, la série de patchs n'est généralement pas régénérée mais la différence est poussée comme nouveau commit à la branche, permettant ainsi d'avancer dans la discussion, tout en conservant intact le contexte du travail passé.

Par exemple, si vous revenez à <<_pr_final>>, vous noterez que le contributeur n'a pas rebasé son commit et n'a pas envoyé une nouvelle requête de tirage.
À la place, il a ajouté de nouveaux commits et les a poussé dans la branche existante.
De cette manière, si on examine cette requête de tirage dans le futur, on peut aisément trouver la totalité de contexte qui a amené aux décisions prises.
L'utilisation du bouton « _Merge_ » sur le site crée à dessein un commit de fusion qui référence la requête de tirage pour qu'il reste simple de revenir sur celle-ci et d'y rechercher la conversation originale si nécessaire.

===== Se maintenir à jour avec le développement amont

Si votre _pull request_ devient obsolète ou ne peut plus être fusionnée proprement, vous voudrez la corriger pour que le mainteneur puisse la fusionner facilement.
GitHub testera cela pour vous et vous indique à la fin de la _Pull Request_ si la fusion automatique est possible ou non. 

[[_pr_fail]]
.La _Pull Request_ ne peut pas être fusionnée proprement
image::images/pr-01-fail.png[Échec de fusion de PR]

Si vous voyez quelque chose comme <<_pr_fail>>, vous voudrez corriger votre branche pour qu'elle devienne verte et que le mainteneur n'ai pas à fournir de travail supplémentaire.

Vous avez deux options. Vous pouvez soit rebaser votre branche sur le sommet de la branche cible (normalement, la branche `master` du dépôt que vous avez dupliqué), soit fusionner la branche cible dans votre branche.

La plupart des développeurs sur GitHub choisirons cette dernière option, pour la même raison que celle citée à la section précédente.
Ce qui importe est l'historique et la fusion finale, donc le rebasage n'apporte pas beaucoup plus qu'un historique légèrement plus propre avec en retour une plus grande difficulté d'application et l'introduction possible d'erreurs.

Si vous voulez fusionnez la branche cible pour rendre votre requête de tirage fusionnable, vous ajouterez le dépôt original comme nouveau dépôt distant, récupérerez la branche cible que vous fusionnerez dans votre branche thématique, corrigerez les erreurs et finalement pousserez la branche thématique sur la même branche thématique pour laquelle vous avez ouvert la requête de tirage.

Par exemple, considérons que dans l'exemple « tonychacon » que nous avons utilisé, l'auteur original a fait des modifications qui créeraient un conflit dans la requête de tirage.
Examinons ces étapes.

[source,shell]
----
$ git remote add upstream https://github.com/schacon/blink <1>

$ git fetch upstream <2>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -> upstream/master

$ git merge upstream/master <3>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <4>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <5>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -> slow-blink
----

<1> Ajoute le dépôt original comme dépôt distant ``upstream''
<2> Récupère les derniers travaux depuis ce dépôt distant
<3> Fusionne la branche principale dans la branche thématique
<4> Corrige le conflit créé
<5> Pousse sur la même branche thématique

Quand vous faîtes ceci, la _Pull Request_ est automatiquement mise à jour et re-vérifiée pour la fusion.

[[_pr_merge_fix]]
.La _Pull Request_ se fusionne proprement maintenant
image::images/pr-02-merge-fix.png[La requête de tirage a été corrigée]

Une des grandes forces de Git est que vous pouvez faire ceci continuellement.
Si vous avez un projet à très long terme, vous pouvez facilement fusionner depuis la branche cible de nombreuses fois et n'avoir qu'à gérer les conflits apparus entre deux fusions, rendant ainsi le processus gérable.

Si vous souhaitez absolument rebaser la branche pour la nettoyer, vous pouvez toujours le faire, mais il vaut mieux ne pas pousser en forçant sur un branche sur laquelle une requête de tirage est déjà ouverte.
Si d'autres personnes l'ont déjà tirée et on travaillé dessus, vous vous exposez aux problèmes décrits dans <<_rebase_peril>>.
À la place, poussez cette branche rebasée vers une nouvelle branche sur GitHub et ouvrez une nouvelle requête de tirage qui référence l'ancienne requête, puis fermez-la.

===== Références

Votre question suivante pourrait être : « Comment faire pour référence l'ancienne requête de tirage ? ».
En fait, il y a de très nombreuses manières de faire référence à d'autres choses depuis à peu près partout où on peut écrire dans GitHub.

Commençons par la manière de faire référence à une autre requête de tirage ou un problème (Issue).
Toutes les requêtes de tirage et tous les problèmes sont identifiés par des nombres qui sont uniques au sein d'un projet.
Par exemple, vous ne pouvez avoir une requête de tirage numéro 3 et un problème numéro 3.
Si vous voulez faire référence à n'importe quelle requête de tirage ou n'importe quel problème depuis une autre requête de tirage ou problème du même projet, il vous suffit d'insérer `#<numéro>` dans n'importe quel commentaire ou n'importe quelle description.
Vous pouvez aussi référencer une requête ou un problème d'un autre dépôt dupliqué du dépôt actuel en utilisant la syntaxe `<utilisateur>#<numéro`, ou carrément un autre dépôt indépendant avec la syntaxe `<utilisateur>/<dépot>#<numéro>`.

Voyons cela avec un exemple.
Disons que nous avons rebasé la branche de l'exemple précédent, créé une nouvelle requête de tirage et nous souhaitons maintenant faire référence à l'ancienne requête de tirage depuis la nouvelle.
Nous souhaitons aussi faire référence à un problème remonté dans un dépôt dupliqué et à un problème soumis dans un projet complêtement différent.
Nous pouvons remplir la description comme dans <<_pr_references>>.

[[_pr_references]]
.Références croisées dans une requête de tirage.
image::images/mentions-01-syntax.png[Références dans un PR]

Quand nous soumettons cette pull request, nous voyons tout ceci mis en forme comme dans <<_pr_references_render>>.

[[_pr_references_render]]
.Références croisées mises en forme dans une Pull Request.
image::images/mentions-02-render.png[Références mises en formes]

Notez bien que l'URL GitHub complète que nous avons indiquée a été raccourcie pour ne contenir que l'information nécessaire.

À présent, si Tony retourne sur la requête de tirage originale et la ferme, nous pouvons voir que du fait de sa référence dans la nouvelle, GitHub a créé automatiquement un évènement de suivi dans le journal de la nouvelle requête de tirage.
Cela signifie qu'une personne qui visitera cette requête de tirage et verra qu'elle est fermée pourra facilement se rendre sur celle qui l'a remplacée.
Le lien ressemblera à quelque chose comme <<_pr_closed>>.

[[_pr_closed]]
.Références croisée dans une PR fermée.
image::images/mentions-03-closed.png[PR fermée]

En plus des numéros de problèmes, vous pouvez aussi faire référence à un commit spécifique par son SHA-1.
Vous devez spécifier la totalité des 40 caractères du SHA-1, mais si GitHub rencontre cette chaîne, il créera un lien direct au commit.
Vous pouvez aussi faire référence à des commits dans des dépôts dupliqués ou d'autres dépôts de la même manière que nous l'avons fait pour les problèmes.

==== Markdown

Faire des liens vers les autres problèmes n'est que le début des choses intéressantes que vous pouvez faire dans presque toutes les boîtes à texte dans GitHub.
Dans les descriptions des problèmes et de Pull Request, les commentaires, les commentaires de code et plus, vous pouvez utiliser ce qu'on appelle le « Markdown, saveur GitHub » (_GitHub Flavored Markdown_).
Markdown, c'est comme écrire comme du texte simple mais rendu richement.


Référez-vous à <<_example_markdown>> pour un exemple pour savoir comment les commentaires ou le texte peuvent être écrits et rendus en Markdown.

[[_example_markdown]]
.Un exemple de Markdown écrit et rendu.
image::images/markdown-01-example.png[Exemple de Markdown]

===== Markdown saveur GitHub

La saveur GitHub de Markdown ajoute plus de choses réalisables au delà de la syntaxe Markdown basique.
Celles-ci peuvent être vraiment utiles pour la création de Pull Request ou de commentaires de problèmes ou de descriptions.

====== Listes de tâches

La première spécificité vraiment utile du Markdown de GitHub, particulièrement dans le cadre de Pull Requests, est la création de listes de tâches.
Une liste de tâche est une liste de cases à cocher pour chaque action à accomplir.
Dans un problème ou une requête de tirage, cela indique les choses qu'on doit faire avant de pouvoir considérer le point comme terminé.

Vous pouvez créer une liste de tâches comme ceci :

[source]
----
- [X] Écrire le  code
- [ ] Écrire tous les tests
- [ ] Documenter le code
----

Si nous incluons ceci dans la description de notre demande de tirage ou de notre problème, nous le verrons rendu comme dans <<_task_lists>>

[[_task_lists]]
.Rendu d'une liste de tâches dans un commentaire Markdown.
image::images/markdown-02-tasks.png[Liste de tâches exemple.]

C'est très utilisé dan les requêtes de tirage pour indiquer tout ce que vous souhaitez voir accompli sur la branche avant que la requête de tirage ne soit effectivement prête à être fusionnée.
La partie vraiment cool est que vous pouvez simplement cliquer les cases à cocher pour mettre à jour le commentaire -- il est inutile d'éditer directement le Markdown pour cocher les cases.

De plus, GitHub surveillera la présence de listes de tâches dans vos problèmes et vos requêtes de tirage et les montrera comme métadata sur les pages qui les listent.
Par exemple, si vous avez une requête de tirage avec des tâches et vous regardez la page de vue d'ensemble de toutes les requêtes de tirage, vous pouvez visualiser l'état d'avancement.
Cela aide les gens à découper les requêtes de tirage en sous-tâches et aide les autres personnes à suivre le progrès sur la branche.
Vous pouvez voir un exemple de cette fonction dans <<_task_list_progress>>.

[[_task_list_progress]]
.Résumé de listes de tâches dans la liste des requêtes de tirage.
image::images/markdown-03-task-summary.png[Liste de tâches exemple]

Ces fonctions sont incroyablement utiles quand vous ouvrez tôt une requête de tirage et l'utilisez pour suivre votre progrès au cours du développement de la fonctionnalité.

====== Extraits de code

Vous pouvez aussi ajouter des extraits de code dans les commentaires.
C'est spécialement utile si vous souhaitez présenter quelque chose que vous _pourriez_ essayer de faire avant de les développer réellement dans votre branche.
C'est aussi souvent utilisé pour ajouter un exemple de code qui ne marche pas ou qui exercerait le code de requête de tirage.

Pour ajouter un extrait de code, vous devez le cloturer (_fence_) avec des guillemets simples inversés.

[source]
----
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```
----

If you add a language name like we did there with 'java', GitHub will also try to syntax highlight the snippet. In the case of the above example, it would end up rendering like <<_md_code>>.

[[_md_code]]
.Rendered fenced code example.
image::images/markdown-04-fenced-code.png[Rendered fenced code]

====== Quoting

If you're responding to a small part of a long comment, you can selectively quote out of the other comment by preceding the lines with the `>` character. In fact, this is so common and so useful that there is a keyboard shortcut for it. If you highlight text in a comment that you want to directly reply to and hit the `r` key, it will quote that text in the comment box for you.

The quotes look something like this:

[source]
----
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?
----

Once rendered, the comment will look like <<_md_quote>>.

[[_md_quote]]
.Rendered quoting example.
image::images/markdown-05-quote.png[Rendered quoting]

====== Emoji

Finally, you can also use emoji in your comments. This is actually used quite extensively in comments you see on many GitHub Issues and Pull Requests. There is even an emoji helper in GitHub. If you are typing a comment and you start with a `:` character, an autocompleter will help you find what you're looking for.

[[_md_emoji_auto]]
.Emoji autocompleter in action.
image::images/markdown-06-emoji-complete.png[Emoji autocompleter]

Emojis take the form of `:<name>:` anywhere in the comment. For instance, you could write something like this:

[source]
----
I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:
----

When rendered, it would look something like <<_md_emoji>>.

[[_md_emoji]]
.Heavy emoji commenting.
image::images/markdown-07-emoji.png[Emoji]

Not that this is incredibly useful, but it does add an element of fun and emotion to a medium that is otherwise hard to convey emotion in.


[NOTE]
====
There are actually quite a number of web services that make use of emoji charaters these days. A great cheat sheet to reference to find emoji that expresses what you want to say can be found at:

http://www.emoji-cheat-sheet.com
====

====== Images

This isn't technically GitHub Flavored Markdown, but it is incredibly useful. In addition to adding Markdown image links to comments, which can be difficult to find and embed URLs for, GitHub allows you to drag and drop images into text areas to embed them.

[[_md_drag]]
.Drag and drop images to upload them and auto-embed them.
image::images/markdown-08-drag-drop.png[Drag and drop images]

If you look back at <<_pr_references>>, you can see a small ``Parsed as Markdown'' hint above the text area. Clicking on that will give you a full cheat sheet of everything you can do with Markdown on GitHub.
